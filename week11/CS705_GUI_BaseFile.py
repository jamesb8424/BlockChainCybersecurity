import datetime
import uuid
from Crypto.Hash import SHA1
from tkinter import *

#### NOTE: DO NOT EDIT THIS FILE ####

# Transaction Class to define the transactions within a block
class Transaction:
    def __init__(self, id, to_party, from_party, datetime: datetime, transaction_info):
        self.id = id # Id of the transaction
        self.to_party = to_party # Who received the transaction
        self.from_party = from_party # Who sent the transaction
        self.datetime = datetime # Datetime of the transaction
        self.transaction_info = transaction_info # Information about the transaction

    # String reference of the transaction object
    def __str__(self):
        return f'{self.id}:{self.datetime}:{self.from_party}:{self.to_party}:{self.transaction_info}'


#### NOTE: DO NOT EDIT THIS FILE ####


# Block class for adding to the block chain and to hold the transactions
class Block:
    def __init__(self, index: int, datetime_stamp: datetime, transactions: list, previous_hash, nonce):
        self.index = index # Block Index
        self.datetime_stamp = datetime_stamp # Date Stamp of the block
        self.transactions = transactions # All of the transactions in the block
        self.previous_hash = previous_hash # Previous block's hash, creating the chain
        self.nonce = nonce # Hash of the block made from hashing the list of transactions

    # String reference of the Block Object
    def __str__(self):
        return f'{self.index},{self.datetime_stamp},{self.nonce},{self.previous_hash},{self.transactions}'


#### NOTE: DO NOT EDIT THIS FILE ####


# Generate a random guid for the transaction
def Generate_Random_UUID():
    return uuid.uuid4().hex


#### NOTE: DO NOT EDIT THIS FILE ####


# Create a datetime stamp based on the current datetime
def Get_DateStamp():
    today = datetime.datetime.today()
    year = today.year
    month = today.month
    day = today.day
    hour = today.hour
    minute = today.minute
    second = today.second

    return f'{year}-{month}-{day}_{hour}:{minute}:{second}'


#### NOTE: DO NOT EDIT THIS FILE ####


# Generate a SHA1 hashed based on the transaction list
def Generate_SHA1(hash_data):
    # create a new sha1 object (Note: For this assignment the hash length was decreased to SHA1, due to screen constraints)
    hash_object = SHA1.new()
    # Iterate over the list
    for data in hash_data:
        # Update the hash object with the hash of the transaction
        hash_object.update(bytes(data, 'utf-8')) # If you receive an error wrap the data in a str()
    # return the hex value of the hash
    return hash_object.hexdigest()


#### NOTE: DO NOT EDIT THIS FILE ####


# Generate a transaction from the command line values
def Generate_Transactions(to_person, from_person, quantity, what_item):
    # Put the quality and item in a string
    info = f'${quantity}:{what_item}'
    # Generate a Transaction using the Transaction Class and return it to be used in the Blockchain
    return Transaction(Generate_Random_UUID(), to_person, from_person, Get_DateStamp(), info )


#### NOTE: DO NOT EDIT THIS FILE ####


# Add the transaction to the blockchain and return the block chain to update the original
def Add_To_BlockChain(blockChain, to_person, from_person, quantity_object, what_object):
    # create an empty list of transactions
    Transactions = []
    # Generate a transaction from the passed values
    transaction = Generate_Transactions(to_person, from_person, quantity_object, what_object)
    # Append the transaction objct to the transactions list as a string
    Transactions.append(str(transaction))
    # Get the length of the blockchain list
    count = len(blockChain)
    # Generate a block for the blockchain using the Transactions list and the Block class
    blockObject = Block(count, Get_DateStamp(),Transactions , blockChain[count - 1].nonce, Generate_SHA1(Transactions))
    # Add the block to the block chain
    blockChain.append(blockObject)
    # Return the blockchain
    return blockChain


#### NOTE: DO NOT EDIT THIS FILE ####


# Add the transaction to the blockchain and return the block chain to update the original
def Create_Block(blockChain, transaction):
    # create an empty list of transactions
    Transactions = [] 
    # Append the transaction objct to the transactions list as a string
    Transactions.append(transaction)
    # Get the length of the blockchain list
    count = len(blockChain)
    # Generate a block for the blockchain using the Transactions list and the Block class
    return Block(count, Get_DateStamp(),Transactions , blockChain[count - 1].nonce, Generate_SHA1(Transactions))


#### NOTE: DO NOT EDIT THIS FILE ####


# Create the genesis block
def Generate_Genesis(blockChain):
    # Add "genesis block" as the data for the transaction in the block
    genesis_data = ["Genesis Block"]
    # Generate the genesis block using the Block class
    genesis = Block(0, Get_DateStamp(), genesis_data, 0, Generate_SHA1(genesis_data))
    # Add the genesis block to the blockchain
    blockChain.append(genesis)
    # Return the blockchain
    return blockChain


#### NOTE: DO NOT EDIT THIS FILE ####

# Update the list box object
def updateList(item, listbox):
    # Insert the object at the end of the GUI list.
    listbox.insert(END, item)


#### NOTE: DO NOT EDIT THIS FILE ####


# Handle the button Press.
def buttonPress(blockChain, listbox,  ToEntry:Entry, FromEntry:Entry, ValueEntry:Entry, ItemEntry:Entry):

    # Validate that all of the input fields are filled out
    result = validateInput(ToEntry.get(), FromEntry.get(), ValueEntry.get(), ItemEntry.get())

    if result:
        # Create the transaction based on the UI Inputs
        transaction = Generate_Transactions(ToEntry.get(), FromEntry.get(), ValueEntry.get(), ItemEntry.get())
        # Generate the new block to add to the blockchain
        new_block = Create_Block(blockChain, str(transaction))
        # Add the block to the block chain
        blockChain.append(new_block)
        # Update the UI list with the newly created block
        updateList(new_block, listbox)
        # Clear the fields so a new transaction can be created
        clearFields(ToEntry, FromEntry, ValueEntry, ItemEntry)
    else:
        print("Inputs cannot be empty")

    return blockChain


#### NOTE: DO NOT EDIT THIS FILE ####


# Clear the fields after creating the block
def clearFields(To:Entry, From:Entry, Value:Entry, Item:Entry):
    # Delete the field variables starting at the 0 place and going to the length of the string
    To.delete(0, len(To.get()))
    From.delete(0, len(From.get()))
    Value.delete(0, len(Value.get()))
    Item.delete(0, len(Item.get()))


#### NOTE: DO NOT EDIT THIS FILE ####


# Validate the input so the user does not create empty blocks
def validateInput(To, From, Value, Item):
    if(len(To) == 0):
        return False
    elif(len(From) == 0):
        return False
    elif(len(Value) == 0):
        return False
    elif(len(Item) == 0):
        return False
    else:
        return True